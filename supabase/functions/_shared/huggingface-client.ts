// HuggingFace API client for AI text generation

import { CONFIG } from './config.ts';

export interface HuggingFaceResponse {
  generated_text: string;
}

export interface HuggingFaceError {
  error: string;
  estimated_time?: number;
}

export class HuggingFaceClient {
  private apiKey: string;
  private baseUrl = 'https://api-inference.huggingface.co/models';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  /**
   * Generate text using HuggingFace API with fallback model support
   */
  async generateText(prompt: string, retryWithFallback = true): Promise<string> {
    try {
      // Try primary model first
      const response = await this.callModel(CONFIG.AI.PRIMARY_MODEL, prompt);
      return this.extractText(response);
    } catch (error) {
      console.error('Primary model failed:', error);
      
      if (retryWithFallback) {
        try {
          // Fallback to secondary model
          console.log('Attempting fallback model...');
          const response = await this.callModel(CONFIG.AI.FALLBACK_MODEL, prompt);
          return this.extractText(response);
        } catch (fallbackError) {
          console.error('Fallback model also failed:', fallbackError);
          throw new Error('Both AI models are currently unavailable. Please try again later.');
        }
      }
      
      throw error;
    }
  }

  /**
   * Call specific HuggingFace model with retry logic
   */
  private async callModel(modelName: string, prompt: string, maxRetries = 3): Promise<HuggingFaceResponse[]> {
    const url = `${this.baseUrl}/${modelName}`;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.AI.TIMEOUT_MS);

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            inputs: prompt,
            parameters: {
              temperature: CONFIG.AI.TEMPERATURE,
              max_new_tokens: CONFIG.AI.MAX_TOKENS,
              return_full_text: false,
              do_sample: true,
            },
          }),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorData = await response.json() as HuggingFaceError;
          
          // Handle model loading (503 error)
          if (response.status === 503 && errorData.estimated_time) {
            if (attempt < maxRetries) {
              const waitTime = Math.min(errorData.estimated_time * 1000, 10000); // Max 10 seconds
              console.log(`Model loading, waiting ${waitTime}ms before retry...`);
              await this.sleep(waitTime);
              continue;
            }
          }
          
          throw new Error(`HuggingFace API error (${response.status}): ${errorData.error}`);
        }

        const data = await response.json() as HuggingFaceResponse[];
        return data;

      } catch (error) {
        if (error.name === 'AbortError') {
          throw new Error('Request timeout - AI model took too long to respond');
        }
        
        if (attempt === maxRetries) {
          throw error;
        }
        
        // Exponential backoff for retries
        const backoffTime = Math.pow(2, attempt) * 1000;
        console.log(`Attempt ${attempt} failed, retrying in ${backoffTime}ms...`);
        await this.sleep(backoffTime);
      }
    }

    throw new Error('Max retries exceeded');
  }

  /**
   * Extract text from HuggingFace response
   */
  private extractText(response: HuggingFaceResponse[]): string {
    if (!response || response.length === 0) {
      throw new Error('Empty response from AI model');
    }

    const text = response[0]?.generated_text?.trim();
    if (!text) {
      throw new Error('No text generated by AI model');
    }

    return text;
  }

  /**
   * Sleep utility for delays
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Test connection to HuggingFace API
   */
  async testConnection(): Promise<boolean> {
    try {
      await this.generateText('Hello', false); // Don't retry with fallback for test
      return true;
    } catch (error) {
      console.error('HuggingFace connection test failed:', error);
      return false;
    }
  }
}

/**
 * Create HuggingFace client instance
 */
export function createHuggingFaceClient(): HuggingFaceClient {
  const apiKey = (globalThis as any).Deno?.env?.get('HF_API_KEY') || process.env.HF_API_KEY;
  if (!apiKey) {
    throw new Error('HF_API_KEY environment variable is required');
  }
  
  return new HuggingFaceClient(apiKey);
}